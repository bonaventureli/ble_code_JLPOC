/*********************************************************************
 * INCLUDES
 */
#include <string.h>
#include <icall.h>
#include "util.h"
/* This Header file contains all BLE API and icall structure definition */
#include "icall_ble_api.h"
#include "board.h"
#include "peripheral.h"
#include "ingeek_ble_server.h"
#include "ingeek_ble_profile.h"
#include "security_digital_key.h"
#include "inc/sdi_task.h"
#include "inc/sdi_tl_uart.h"

/*********************************************************************
 * MACROS
 */
#define AUTO_NOTIFICATION FALSE
/*********************************************************************
 * CONSTANTS
 */

#define SERVAPP_NUM_ATTR_SUPPORTED        25

gattAttribute_t DKServiceAttrTbl[SERVAPP_NUM_ATTR_SUPPORTED];
/*********************************************************************
 * TYPEDEFS
 */

/*********************************************************************

 * GLOBAL VARIABLES
 */
// Digital key Service Profile Service UUID: 0xFFF0
CONST uint8 DKServUUID[ATT_UUID_SIZE] =
{
  TI_BASE_UUID_128(DKSERVER_SERV_UUID)
};

// Characteristic Status UUID: 0xFFF1
CONST uint8 DKServStatusUUID[ATT_UUID_SIZE] =
{
  TI_BASE_UUID_128(DKSERVER_STATUS_UUID)
};

// Characteristic info UUID: 0xFFF2
CONST uint8 DKServInfoUUID[ATT_UUID_SIZE] =
{
  TI_BASE_UUID_128(DKSERVER_INFO_UUID)
};

// Characteristic auth UUID: 0xFFF3
CONST uint8 DKServAuthUUID[ATT_UUID_SIZE] =
{
  TI_BASE_UUID_128(DKSERVER_AUTH_UUID)
};

// Characteristic session UUID: 0xFFF4
CONST uint8 DKServSessionUUID[ATT_UUID_SIZE] =
{
  TI_BASE_UUID_128(DKSERVER_SESSION_UUID)
};

// Characteristic cmd UUID: 0xFFF5
CONST uint8 DKServCmdUUID[ATT_UUID_SIZE] =
{
  TI_BASE_UUID_128(DKSERVER_CMD_UUID)
};

// Characteristic Rssi UUID: 0xFFF6
CONST uint8 DKServRssiUUID[ATT_UUID_SIZE] =
{
  TI_BASE_UUID_128(DKSERVER_RSSI_UUID)
};

// Characteristic Version UUID: 0xFFF7
CONST uint8 DKServVersionUUID[ATT_UUID_SIZE] =
{
  TI_BASE_UUID_128(DKSERVER_VERSION_UUID)
};

/*********************************************************************
 * EXTERNAL VARIABLES
 */
// Clock instances for internal periodic events.
extern bool xiaochengxu;
extern Ingeek_StateM_t statem;
extern INFO_DATA info_t;
extern bool ifLOG;
/*********************************************************************
 * EXTERNAL FUNCTIONS
 */

/*********************************************************************
 * LOCAL VARIABLES
 */
static DigitalkeyServiceCBs_t *DigitalkeyService_AppCBs = NULL;

/*********************************************************************
 * Profile Attributes - variables
 */

// Digital key Profile Service attribute
static CONST gattAttrType_t DigitalkeyService = { ATT_UUID_SIZE, DKServUUID };

//status
static uint8 DigitalkeyServicestatusProps = GATT_PROP_READ|GATT_PROP_NOTIFY;
static gattCharCfg_t *DigitalkeyServicestatusConfig;
uint8 DigitalkeyServicestatus = 0;
static uint8 DigitalkeyServicestatusUserDesp[23] = "status Characteristic \0";

//info
static uint8 DigitalkeyServiceinfoProps = GATT_PROP_READ | GATT_PROP_WRITE;
uint8 DigitalkeyServiceinfo[DKSERVER_INFO_LEN] = {0};
static uint8 DigitalkeyServiceinfolen = 0;
static uint8 DigitalkeyServiceinfoUserDesp[21] = "info Characteristic \0";

//auth
static uint8 DigitalkeyServiceauthProps = GATT_PROP_WRITE;
static uint8 DigitalkeyServiceauth[DKSERVER_AUTH_LEN] = {0};
static uint8 DigitalkeyServiceauthlen = 0;
static uint8 DigitalkeyServiceauthUserDesp[21] = "auth Characteristic \0";

//session
static uint8 DigitalkeyServicesessionProps = GATT_PROP_WRITE|GATT_PROP_NOTIFY;
uint8 DigitalkeyServicesession[DKSERVER_SESSION_LEN] = {0};
static uint8 DigitalkeyServicesessionlen = 0;
static gattCharCfg_t *DigitalkeyServicesessionConfig;
static uint8 DigitalkeyServicesessionUserDesp[28] = "session Characteristic \0";

//cmd
static uint8 DigitalkeyServicecmdProps = GATT_PROP_WRITE |GATT_PROP_NOTIFY;
static uint8 DigitalkeyServicecmd[DKSERVER_CMD_LEN] = {0};
static uint8 DigitalkeyServicecmdlen = 0;
static gattCharCfg_t *DigitalkeyServicecmdConfig;
static uint8 DigitalkeyServicecmdUserDesp[21] = "cmd Characteristic \0";

//rssi
static uint8 DigitalkeyServicerssiProps = GATT_PROP_WRITE;
static uint8 DigitalkeyServicerssi[DKSERVER_RSSI_LEN] = {0};
static uint8 DigitalkeyServicerssilen = 0;
static uint8 DigitalkeyServicerssiUserDesp[23] = "rssi Characteristic \0";

//version
static uint8 DigitalkeyServiceversionProps = GATT_PROP_READ | GATT_PROP_WRITE;
static uint8 DigitalkeyServiceversion[DKSERVER_VER_LEN] = {0};
static uint8 DigitalkeyServiceversionlen = 0;
static uint8 DigitalkeyServiceversionUserDesp[30] = "version Characteristic \0";



//Keep track of length
//static uint8 charDataValueLen = DKSERVER_INFO_LEN;

/*********************************************************************
 * Profile Attributes - Table
 */

gattAttribute_t DKServiceAttrTbl[SERVAPP_NUM_ATTR_SUPPORTED] =
{
	// Serial Port Profile Service
	{
		{ ATT_BT_UUID_SIZE, primaryServiceUUID }, /* type */
		GATT_PERMIT_READ,                         /* permissions */
		0,                                        /* handle */
		(uint8 *)&DigitalkeyService            /* pValue */
	},

//status
	// Characteristic status Declaration
	{
	  { ATT_BT_UUID_SIZE, characterUUID },
	  GATT_PERMIT_READ,
	  0,
	  &DigitalkeyServicestatusProps
	},

	// Characteristic status Value
	{
		{ ATT_UUID_SIZE, DKServStatusUUID },
		GATT_PERMIT_READ,
		0,
		&DigitalkeyServicestatus
	},

	// Characteristic status configuration
	{
		{ ATT_BT_UUID_SIZE, clientCharCfgUUID },
		GATT_PERMIT_READ| GATT_PERMIT_WRITE,
		0,
		(uint8 *)&DigitalkeyServicestatusConfig
	},

	// Characteristic status User Description
	{
		{ ATT_BT_UUID_SIZE, charUserDescUUID },
		GATT_PERMIT_READ,
		0,
		DigitalkeyServicestatusUserDesp
	},
//info
    // Characteristic info Declaration
    {
		{ ATT_BT_UUID_SIZE, characterUUID },
		GATT_PERMIT_READ,
		0,
		&DigitalkeyServiceinfoProps
    },

	// Characteristic info Value
	{
		{ ATT_UUID_SIZE, DKServInfoUUID },
		GATT_PERMIT_READ | GATT_PERMIT_WRITE,
		0,
		DigitalkeyServiceinfo
	},

	// Characteristic info User Description
	{
		{ ATT_BT_UUID_SIZE, charUserDescUUID },
		GATT_PERMIT_READ,
		0,
		DigitalkeyServiceinfoUserDesp
	},

//version
	    // Characteristic version Declaration
	    {
	        { ATT_BT_UUID_SIZE, characterUUID },
	        GATT_PERMIT_READ,
	        0,
	        &DigitalkeyServiceversionProps
	    },

	    // Characteristic version Value
	    {
	        { ATT_UUID_SIZE, DKServVersionUUID },
	        GATT_PERMIT_READ | GATT_PERMIT_WRITE,
	        0,
	        DigitalkeyServiceversion
	    },

	    // Characteristic version User Description
	    {
	        { ATT_BT_UUID_SIZE, charUserDescUUID },
	        GATT_PERMIT_READ,
	        0,
	        DigitalkeyServiceversionUserDesp
	    },
//auth
    // Characteristic auth Declaration
    {
		{ ATT_BT_UUID_SIZE, characterUUID },
		GATT_PERMIT_READ,
		0,
		&DigitalkeyServiceauthProps
    },

	// Characteristic Value auth
	{
		{ ATT_UUID_SIZE, DKServAuthUUID },
		GATT_PERMIT_WRITE,
		0,
		DigitalkeyServiceauth
	},

	// Characteristic auth User Description
	{
		{ ATT_BT_UUID_SIZE, charUserDescUUID },
		GATT_PERMIT_READ,
		0,
		DigitalkeyServiceauthUserDesp
	},
//session
    // Characteristic session Declaration
    {
		{ ATT_BT_UUID_SIZE, characterUUID },
		GATT_PERMIT_READ,
		0,
		&DigitalkeyServicesessionProps
    },

	// Characteristic Value session
	{
		{ ATT_UUID_SIZE, DKServSessionUUID },
		GATT_PERMIT_WRITE,
		0,
		DigitalkeyServicesession
	},
    {
        { ATT_BT_UUID_SIZE, clientCharCfgUUID },
        GATT_PERMIT_READ | GATT_PERMIT_WRITE,
        0,
        (uint8 *)&DigitalkeyServicesessionConfig
    },
	// Characteristic session User Description
	{
		{ ATT_BT_UUID_SIZE, charUserDescUUID },
		GATT_PERMIT_READ,
		0,
		DigitalkeyServicesessionUserDesp
	},
//cmd
	// Characteristic cmd Declaration
	{
		{ ATT_BT_UUID_SIZE, characterUUID },
		GATT_PERMIT_READ,
		0,
		&DigitalkeyServicecmdProps
	},

	// Characteristic cmd Value
	{
		{ ATT_UUID_SIZE, DKServCmdUUID },
		 GATT_PERMIT_WRITE,
		0,
		DigitalkeyServicecmd
	},

	{
	    { ATT_BT_UUID_SIZE, clientCharCfgUUID },
	    GATT_PERMIT_READ | GATT_PERMIT_WRITE,
	    0,
	    (uint8 *)&DigitalkeyServicecmdConfig
	},
	// Characteristic cmd User Description
	{
		{ ATT_BT_UUID_SIZE, charUserDescUUID },
		GATT_PERMIT_READ,
		0,
		DigitalkeyServicecmdUserDesp
	},
//rssi
    // Characteristic rssi Declaration
    {
		{ ATT_BT_UUID_SIZE, characterUUID },
		GATT_PERMIT_READ,
		0,
		&DigitalkeyServicerssiProps
    },

	// Characteristic Value rssi
	{
		{ ATT_UUID_SIZE, DKServRssiUUID },
		GATT_PERMIT_WRITE,
		0,
		DigitalkeyServicerssi
	},

	// Characteristic rssi User Description
	{
		{ ATT_BT_UUID_SIZE, charUserDescUUID },
		GATT_PERMIT_READ,
		0,
		DigitalkeyServicerssiUserDesp
	},

	//vsersion
	    // Characteristic version Declaration
	    {
	        { ATT_BT_UUID_SIZE, characterUUID },
	        GATT_PERMIT_READ,
	        0,
	        &DigitalkeyServicerssiProps
	    },

	    // Characteristic Value verssion
	    {
	        { ATT_UUID_SIZE, DKServRssiUUID },
	        GATT_PERMIT_WRITE,
	        0,
	        DigitalkeyServicerssi
	    },

	    // Characteristic vesrsion User Description
	    {
	        { ATT_BT_UUID_SIZE, charUserDescUUID },
	        GATT_PERMIT_READ,
	        0,
	        DigitalkeyServiceversionUserDesp
	    },
};

/*********************************************************************
 * LOCAL FUNCTIONS
 */
static bStatus_t DigitalkeyService_ReadAttrCB( uint16 connHandle, gattAttribute_t *pAttr,
                                           uint8 *pValue, uint16 *pLen, uint16 offset,
                                           uint16 maxLen, uint8 method );
static bStatus_t DigitalkeyService_WriteAttrCB( uint16 connHandle, gattAttribute_t *pAttr,
                                            uint8 *pValue, uint16 len, uint16 offset,
                                            uint8 method );


/*********************************************************************
 * PROFILE CALLBACKS
 */
// Serial Port Profile Service Callbacks
CONST gattServiceCBs_t DigitalkeyServiceCBs =
{
  DigitalkeyService_ReadAttrCB,  // Read callback function pointer
  DigitalkeyService_WriteAttrCB, // Write callback function pointer
  NULL                       // Authorization callback function pointer
};

/*********************************************************************
 * PUBLIC FUNCTIONS
 */

/*********************************************************************
 * @fn      DigitalkeyService_AddService
 *
 * @brief   Initializes the Serial Port Profile service by registering
 *          GATT attributes with the GATT server.
 *
 * @param   services - services to add. This is a bit map and can
 *                     contain more than one service.
 *
 * @return  Success or Failure
 */
bStatus_t DigitalkeyService_AddService( uint32 services )
{
  uint8 status;

  // Allocate Client Characteristic Configuration table
  DigitalkeyServicestatusConfig = (gattCharCfg_t *)ICall_malloc( sizeof(gattCharCfg_t) *linkDBNumConns);
  if ( DigitalkeyServicestatusConfig == NULL )
  {
    return ( bleMemAllocError );
  }

  DigitalkeyServicesessionConfig = (gattCharCfg_t *)ICall_malloc( sizeof(gattCharCfg_t) *linkDBNumConns);
  if ( DigitalkeyServicesessionConfig == NULL )
  {
    return ( bleMemAllocError );
  }

  DigitalkeyServicecmdConfig = (gattCharCfg_t *)ICall_malloc( sizeof(gattCharCfg_t) *linkDBNumConns);
  if ( DigitalkeyServicecmdConfig == NULL )
  {
    return ( bleMemAllocError );
  }
  // Initialize Client Characteristic Configuration attributes
  GATTServApp_InitCharCfg( INVALID_CONNHANDLE, DigitalkeyServicestatusConfig );
  GATTServApp_InitCharCfg( INVALID_CONNHANDLE, DigitalkeyServicesessionConfig );
  GATTServApp_InitCharCfg( INVALID_CONNHANDLE, DigitalkeyServicecmdConfig );

  if ( services & DKSERVER_SERVICE )
  {
    // Register GATT attribute list and CBs with GATT Server App
    status = GATTServApp_RegisterService( DKServiceAttrTbl,
                                          GATT_NUM_ATTRS( DKServiceAttrTbl ),
                                          16,
                                          &DigitalkeyServiceCBs );
  }
  else
  {
    status = SUCCESS;
  }

  return ( status );
}

/*********************************************************************
 * @fn      DigitalkeyService_RegisterAppCBs
 *
 * @brief   Registers the application callback function. Only call
 *          this function once.
 *
 * @param   callbacks - pointer to application callbacks.
 *
 * @return  SUCCESS or bleAlreadyInRequestedMode
 */
bStatus_t DigitalkeyService_RegisterAppCBs( DigitalkeyServiceCBs_t *appCallbacks )
{
  if ( appCallbacks )
  {
    DigitalkeyService_AppCBs = appCallbacks;

    return ( SUCCESS );
  }
  else
  {
    return ( bleAlreadyInRequestedMode );
  }
}

/*********************************************************************
 * @fn      DigitalkeyService_SetParameter
 *
 * @brief   Set a Digital key Profile parameter.
 *
 * @param   param - Profile parameter ID
 * @param   len - length of data to write
 * @param   value - pointer to data to write.  This is dependent on
 *          the parameter ID and WILL be cast to the appropriate
 *          data type (example: data type of uint16 will be cast to
 *          uint16 pointer).
 *
 * @return  bStatus_t
 */
bStatus_t DigitalkeyService_SetParameter( uint8 param, void *value,uint32_t len)
{
  bStatus_t ret = SUCCESS;
  switch ( param )
  {
    case DKSERVER_CHAR_STATUS:	  
	  if ( len == sizeof ( uint8 ) )
      {
        DigitalkeyServicestatus = *((uint8*)value);

        // See if Notification has been enabled
        GATTServApp_ProcessCharCfg( DigitalkeyServicestatusConfig, &DigitalkeyServicestatus, FALSE,
                                    DKServiceAttrTbl, GATT_NUM_ATTRS( DKServiceAttrTbl ),
                                    INVALID_TASK_ID, DigitalkeyService_ReadAttrCB );
      }
      else
      {
        ret = bleInvalidRange;
      }
      break;

    case DKSERVER_CHAR_INFO:
     if ( len <= DKSERVER_INFO_LEN )
      {
        VOID memcpy( DigitalkeyServiceinfo, value, len );
        DigitalkeyServiceinfolen=len;
      }
      else
      {
        ret = bleInvalidRange;
      }
      break;

    case DKSERVER_CHAR_VERSION:
         if ( len <= DKSERVER_VER_LEN )
          {
            VOID memcpy( DigitalkeyServiceversion, value, len );
            DigitalkeyServiceversionlen=len;
          }
          else
          {
            ret = bleInvalidRange;
          }
          break;

    case DKSERVER_CHAR_SESSION:
        if (len <= DKSERVER_SESSION_LEN ){
            DigitalkeyServicesessionlen=len;
            VOID memcpy(DigitalkeyServicesession,value, len);
            // See if Notification has been enabled
            GATTServApp_ProcessCharCfg( DigitalkeyServicesessionConfig, DigitalkeyServicesession, FALSE,
                                      DKServiceAttrTbl, GATT_NUM_ATTRS( DKServiceAttrTbl ),
                                      INVALID_TASK_ID, DigitalkeyService_ReadAttrCB );
        }
        else{
          ret = bleInvalidRange;
        }
        break;
    case DKSERVER_CHAR_CMD:
        if (len <= DKSERVER_CMD_LEN ){
            DigitalkeyServicecmdlen=len;
            VOID memcpy(DigitalkeyServicecmd, value, len );
            // See if Notification has been enabled
            GATTServApp_ProcessCharCfg( DigitalkeyServicecmdConfig, DigitalkeyServicecmd, FALSE,
                                      DKServiceAttrTbl, GATT_NUM_ATTRS( DKServiceAttrTbl ),
                                      INVALID_TASK_ID, DigitalkeyService_ReadAttrCB );
        }
        else{
          ret = bleInvalidRange;
        }
        break;
    default:
      ret = INVALIDPARAMETER;
      break;
  }

  return ( ret );
}


/*********************************************************************
 * @fn      DigitalkeyService_GetParameter
 *
 * @brief   Get a Digital key Service Profile parameter.
 *
 * @param   param - Profile parameter ID
 * @param   value - pointer to data to put.  This is dependent on
 *          the parameter ID and WILL be cast to the appropriate
 *          data type (example: data type of uint16 will be cast to
 *          uint16 pointer).
 *
 * @return  bStatus_t
 */
bStatus_t DigitalkeyService_GetParameter( uint8 param, void *value,uint32_t *returnBytes)
{
  bStatus_t ret = SUCCESS;
  switch ( param )
  {
    case DKSERVER_CHAR_AUTH:
      VOID memcpy( value, DigitalkeyServiceauth, DigitalkeyServiceauthlen );
      *returnBytes = DigitalkeyServiceauthlen;
      break;
    case DKSERVER_CHAR_SESSION:
      VOID memcpy( value, DigitalkeyServicesession, DigitalkeyServicesessionlen );
      *returnBytes = DigitalkeyServicesessionlen;
      break;
    case DKSERVER_CHAR_INFO:
      VOID memcpy( value, DigitalkeyServiceinfo, DigitalkeyServiceinfolen );
      *returnBytes = DigitalkeyServiceinfolen;
      break;

    case DKSERVER_CHAR_VERSION:
      VOID memcpy( value, DigitalkeyServiceversion, DigitalkeyServiceversionlen );
      *returnBytes = DigitalkeyServiceversionlen;
      break;

    case DKSERVER_CHAR_CMD:
      VOID memcpy( value, DigitalkeyServicecmd, DigitalkeyServicecmdlen );
      *returnBytes = DigitalkeyServicecmdlen;
      break;
    case DKSERVER_CHAR_RSSI:
	  VOID memcpy( value, DigitalkeyServicerssi, DigitalkeyServicerssilen );
	  *returnBytes = DigitalkeyServicerssilen;
      break;
    default:
      ret = INVALIDPARAMETER;
      break;
  }

  return ( ret );
}

/*********************************************************************
 * @fn          DigitalkeyService_ReadAttrCB
 *
 * @brief       Read an attribute.
 *
 * @param       connHandle - connection message was received on
 * @param       pAttr - pointer to attribute
 * @param       pValue - pointer to data to be read
 * @param       pLen - length of data to be read
 * @param       offset - offset of the first octet to be read
 * @param       maxLen - maximum length of data to be read
 * @param       method - type of read message
 *
 * @return      SUCCESS, blePending or Failure
 */
static bStatus_t DigitalkeyService_ReadAttrCB( uint16 connHandle, gattAttribute_t *pAttr,
                                           uint8 *pValue, uint16 *pLen, uint16 offset,
                                           uint16 maxLen, uint8 method )
{
  bStatus_t status = SUCCESS;
  uint8 notifyApp = 0xFF;

  if ( gattPermitAuthorRead( pAttr->permissions ) ){
    return ( ATT_ERR_INSUFFICIENT_AUTHOR );
  }
  if ( offset > 0 ){
    return ( ATT_ERR_ATTR_NOT_LONG );
  }

  if ( pAttr->type.len == ATT_UUID_SIZE ){
    uint16 uuid = BUILD_UINT16( pAttr->type.uuid[12], pAttr->type.uuid[13]); // Get 16-bit UUID from 128-bit UUID

    switch ( uuid )
    {
		case DKSERVER_STATUS_UUID :
		    *pLen = 1;
			pValue[0] = *pAttr->pValue;
			//DEBUG("read.status"); DEBUG((uint8_t*)convInt32ToText((int)pValue[0])); DEBUG_NEWLINE();
			break;
		case DKSERVER_INFO_UUID :
	        if(true == ifLOG){
	            DEBUG("info_read");DEBUG_NEWLINE();
	        }

		   // if(statem.status == CARINFO_VALID){/*check status if is 0x00 can be readed*/
		        //if(info_t.flag == SUCCESS && info_t.infolen != 0){/*Rely on MTUsize*/
		            //DEBUG("info_t.flag == SUCCESS");DEBUG_NEWLINE();

#ifndef BLE_SCANNER_DEBUG
                    *pLen=info_t.infolen;
                    VOID memcpy(pValue,info_t.info_data,info_t.infolen);
#else

					*pLen = VIN_LEN;
					VOID memcpy(pValue,statem.vin, VIN_LEN);
#endif
                    DigitalkeyServicestatus=READ_INFO;/*chanage status to 0x01*/
					//DigitalkeyServicestatus=0x80;
                    statem.status=READ_INFO;
                    //DEBUG("33333");DEBUG_NEWLINE();
                    //uint8_t status[10] = {0x7E,0x10,0x10,0x02,0xFF,0xF1,0x01,0x01,0xFF,0xFF};
                    //UART_WriteTransport (status, 10);
               // }
                //else{
                    //DigitalkeyServicestatus = CARINFO_INVALID;/*chanage status to 0xFF*/
                    //statem.status=CARINFO_INVALID;
                //}
		    //}
			break;
		case DKSERVER_VERSION_UUID :
            *pLen = 17;
            //VOID memcpy( pValue, pAttr->pValue, DigitalkeyServiceversionlen );
            VOID memcpy( pValue, statem.version, 17);
            break;

        case DKSERVER_SESSION_UUID :
            *pLen = DigitalkeyServicesessionlen;
            VOID memcpy( pValue, pAttr->pValue, DigitalkeyServicesessionlen );
            break;
		case DKSERVER_CMD_UUID :
			*pLen = DigitalkeyServicecmdlen;
			VOID memcpy( pValue, pAttr->pValue, DigitalkeyServicecmdlen );
			break;
      default:
        // Should never get here! (characteristics 3 and 4 do not have read permissions)
        *pLen = 0;
        status = ATT_ERR_ATTR_NOT_FOUND;
        break;
    }
  }
  else if( pAttr->type.len == ATT_BT_UUID_SIZE){
    uint16 uuid = BUILD_UINT16( pAttr->type.uuid[0], pAttr->type.uuid[1]);
    switch ( uuid )
    {
      default:
        // Should never get here!
        *pLen = 0;
        status = ATT_ERR_ATTR_NOT_FOUND;
        break;
    }
  }
  else{
    //neither 16-bit UUID nor 128bit UUID
    *pLen = 0;
    status = ATT_ERR_INVALID_HANDLE;
  }



  return ( status );
}

/*********************************************************************
 * @fn      DigitalkeyService_WriteAttrCB
 *
 * @brief   Validate attribute data prior to a write operation
 *
 * @param   connHandle - connection message was received on
 * @param   pAttr - pointer to attribute
 * @param   pValue - pointer to data to be written
 * @param   len - length of data
 * @param   offset - offset of the first octet to be written
 * @param   method - type of write message
 *
 * @return  SUCCESS, blePending or Failure
 */
static bStatus_t DigitalkeyService_WriteAttrCB( uint16 connHandle, gattAttribute_t *pAttr,
                                            uint8 *pValue, uint16 len, uint16 offset,
                                            uint8 method )
{
  bStatus_t status = SUCCESS;
  uint8 notifyApp = 0xFF;
  if(true == ifLOG){
      //DEBUG("write len: "); DEBUG((uint8_t*)convInt32ToText((int)len)); DEBUG_NEWLINE();
  }
  // If attribute permissions require authorization to write, return error
  if ( gattPermitAuthorWrite( pAttr->permissions ) ){
    // Insufficient authorization
    return ( ATT_ERR_INSUFFICIENT_AUTHOR );
  }

  if ( pAttr->type.len == ATT_UUID_SIZE ){
    uint16 uuid = BUILD_UINT16( pAttr->type.uuid[12], pAttr->type.uuid[13]);
    switch ( uuid )
    {

      case DKSERVER_AUTH_UUID:

          //DEBUG("AUTH1");DEBUG_NEWLINE();
          //if(statem.status == READ_INFO){ //¼æÈÝÐ¡³ÌÐò
            if ( offset == 0 ){
              if ( len > DKSERVER_AUTH_LEN ){
                status = ATT_ERR_INVALID_VALUE_SIZE;
              }
            }
            else{
              status = ATT_ERR_ATTR_NOT_LONG;
            }

            if ( status == SUCCESS ){
                if(xiaochengxu == false){
                 uint8 *pCurValue = (uint8 *)pAttr->pValue;
                 //DEBUG("AUTH2");DEBUG_NEWLINE();
                 DigitalkeyServiceauthlen = len;
                 memcpy(pCurValue, pValue, len);
                }else if(xiaochengxu == true){
                    uint8 *pCurValue = (uint8 *)pAttr->pValue;
                    DigitalkeyServiceauthlen = len;
                    memcpy(pCurValue, pValue, len);
                    if(true == ifLOG){
                        //DEBUG("xiaochengxu");DEBUG_NEWLINE();
                    }
                }
#ifdef 0    //BLE_SCANNER_DEBUG

                 if(len <20){
                      memcpy(pCurValue+DigitalkeyServiceauthlen, pValue, len);
                      DigitalkeyServiceauthlen +=len;
                      notifyApp = DKSERVER_CHAR_AUTH;
                   }
                   else{
                      memcpy(pCurValue+DigitalkeyServiceauthlen, pValue, len);
                      DigitalkeyServiceauthlen += len;
                      if(DigitalkeyServiceauthlen == 80){
                          notifyApp = DKSERVER_CHAR_AUTH;
                      }
                      else
                          return ATT_ERR_INVALID_HANDLE;
                   }
#endif
            //}
            notifyApp = DKSERVER_CHAR_AUTH;
          }
          break;

      case DKSERVER_VERSION_UUID:
            if ( offset == 0 ){
             if ( len > DKSERVER_VER_LEN ){
                status = ATT_ERR_INVALID_VALUE_SIZE;
             }
            }
            else{
             status = ATT_ERR_ATTR_NOT_LONG;
            }

            if ( status == SUCCESS ){
                uint8 *pCurValue = (uint8 *)pAttr->pValue;
                memcpy(pCurValue, pValue, len);
                DigitalkeyServiceversionlen = len;
                notifyApp = DKSERVER_CHAR_VERSION;
             }
       break;

      case DKSERVER_SESSION_UUID:
          //if(statem.status == WRITE_AUTH){
            if ( offset == 0 ){
             if ( len > DKSERVER_SESSION_LEN ){
                status = ATT_ERR_INVALID_VALUE_SIZE;
             }
            }
            else{
             status = ATT_ERR_ATTR_NOT_LONG;
            }

            if ( status == SUCCESS ){
                //DEBUG("write session");DEBUG_NEWLINE();
                uint8 *pCurValue = (uint8 *)pAttr->pValue;
#ifndef BLE_SCANNER_DEBUG
                DigitalkeyServicesessionlen =len;
                memcpy(pCurValue, pValue, len);
#else

                if(len <20){
                   memcpy(pCurValue+DigitalkeyServicesessionlen, pValue, len);
                   DigitalkeyServicesessionlen +=len;
                   notifyApp = DKSERVER_CHAR_SESSION;
                }
                else{
                   memcpy(pCurValue+DigitalkeyServicesessionlen, pValue, len);
                   DigitalkeyServicesessionlen += len;

                   //if(DigitalkeyServicesessionlen == 80){
                   //    notifyApp = DKSERVER_CHAR_SESSION;
                   //}
                   //else
                   return ATT_ERR_INVALID_HANDLE;
                }
#endif
            }
            notifyApp = DKSERVER_CHAR_SESSION;
          //}
          break;
      case DKSERVER_INFO_UUID:
          //if(statem.status == CARINFO_INVALID){/*check status if 0xFF can be writed*/
                if ( offset == 0 ){
                 if ( len > DKSERVER_INFO_LEN ){
                    status = ATT_ERR_INVALID_VALUE_SIZE;
                 }
                }
                else{
                 status = ATT_ERR_ATTR_NOT_LONG;
                }

                if ( status == SUCCESS ){
                    uint8 *pCurValue = (uint8 *)pAttr->pValue;
#ifndef BLE_SCANNER_DEBUG
                    DigitalkeyServiceinfolen =len;
                    memcpy(pCurValue, pValue, len);
                    memcpy(DigitalkeyServiceinfo, pValue, len);
#else
                   if(len <20){
                        memcpy(pCurValue+DigitalkeyServiceinfolen, pValue, len);
                       DigitalkeyServiceinfolen +=len;
                   }
                    else{
                        memcpy(pCurValue+DigitalkeyServiceinfolen, pValue, len);
                        DigitalkeyServiceinfolen += len;
                        return ATT_ERR_INVALID_HANDLE;
                    }
#endif

                 }
                notifyApp = DKSERVER_CHAR_INFO;
           //}
           break;
      case DKSERVER_CMD_UUID:
        if(statem.status == WRITE_SESSION){
            if ( offset == 0 ){
             if ( len > DKSERVER_CMD_LEN ){
                status = ATT_ERR_INVALID_VALUE_SIZE;
             }
            }
            else{
             status = ATT_ERR_ATTR_NOT_LONG;
            }

            if ( status == SUCCESS ){
              uint8 *pCurValue = (uint8 *)pAttr->pValue;
              memset(pCurValue,0x00, DKSERVER_CMD_LEN);
              DigitalkeyServicecmdlen=len;
              memcpy(pCurValue, pValue, len);
              notifyApp = DKSERVER_CHAR_CMD;
            }
        }
        break;
      case DKSERVER_RSSI_UUID:
        if ( offset == 0 ){
         if ( len > DKSERVER_RSSI_LEN ){
            status = ATT_ERR_INVALID_VALUE_SIZE;
         }
        }
        else{
         status = ATT_ERR_ATTR_NOT_LONG;
        }

        if ( status == SUCCESS ){
          uint8 *pCurValue = (uint8 *)pAttr->pValue;
          memset(pCurValue, 0, DKSERVER_RSSI_LEN);
          DigitalkeyServicerssilen=len;
          memcpy(pCurValue, pValue, len);
          notifyApp = DKSERVER_CHAR_RSSI;
        }
        break;		
      default:
        // Should never get here! (characteristics 2 and 4 do not have write permissions)
        status = ATT_ERR_ATTR_NOT_FOUND;
        break;
    }
  }
  else if (pAttr->type.len == ATT_BT_UUID_SIZE ){
    uint16 uuid = BUILD_UINT16( pAttr->type.uuid[0], pAttr->type.uuid[1]);
    switch ( uuid )
    {
    case GATT_CLIENT_CHAR_CFG_UUID:
       status = GATTServApp_ProcessCCCWriteReq( connHandle, pAttr, pValue, len,
                                                 offset, GATT_CLIENT_CFG_NOTIFY );
       if(true == ifLOG){
           DEBUG("CFG");DEBUG_NEWLINE();
       }

       break;
    default:
        status = ATT_ERR_ATTR_NOT_FOUND;
        break;
    }
  }
  else{
      status = ATT_ERR_INVALID_HANDLE;
  }

  // If a charactersitic value changed then callback function to notify application of change
  if ( (notifyApp != 0xFF ) && DigitalkeyService_AppCBs && DigitalkeyService_AppCBs->pfnDigitalkeyServiceChange ){
    DigitalkeyService_AppCBs->pfnDigitalkeyServiceChange( notifyApp );
  }

  return (status);
}


void  Characteristic_zeroize(uint8_t paramID)
{
    switch(paramID)
    {
        case DKSERVER_CHAR_AUTH:
            memset(DigitalkeyServiceauth, 0x00, DKSERVER_AUTH_LEN);
            DigitalkeyServiceauthlen=0;
            break;
        case DKSERVER_CHAR_SESSION:
            memset(DigitalkeyServicesession, 0x00, DKSERVER_SESSION_LEN);
            DigitalkeyServicesessionlen=0;
            break;
        case DKSERVER_CHAR_INFO:
            memset(DigitalkeyServiceinfo, 0x00, DKSERVER_INFO_LEN);
            DigitalkeyServiceinfolen=0;
            break;
        case DKSERVER_CHAR_CMD:
            memset(DigitalkeyServicecmd, 0x00, DKSERVER_CMD_LEN);
            DigitalkeyServicecmdlen=0;
            break;
        case DKSERVER_CHAR_VERSION:
            memset(DigitalkeyServiceversion, 0x00, DKSERVER_VER_LEN);
            DigitalkeyServiceversionlen=0;
            break;
        default:
          // should not reach here!
          break;
    }
}

/*********************************************************************
*********************************************************************/
