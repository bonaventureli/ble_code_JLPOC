#include <string.h>
#include <ti/sysbios/knl/Task.h>
#include <ti/sysbios/knl/Clock.h>
#include <ti/sysbios/knl/Event.h>
#include <ti/sysbios/knl/Queue.h>
#include "util.h"
#include "icall_ble_api.h"
#include "devinfoservice.h"
#include "peripheral.h"
#include "board.h"
#include "ingeek_ble_profile.h"
#include "ingeek_ble_server.h"
#include "security_digital_key.h"
#include "inc/sdi_task.h"
#include "inc/sdi_tl_uart.h"
#ifdef FEATURE_OAD
#include "oad_target.h"
#include "oad.h"
#endif /* FEATURE_OAD */

#ifdef USE_RCOSC
#include "rcosc_calibration.h"
#endif //USE_RCOSC

#include <hal/src/target/_common/TRNGCC26XX.h>
/*********************************************************************
 * CONSTANTS
 */
#define DBG_KALMAN_FILTER   1
#define DEFAULT_ADVERTISING_INTERVAL          160
#define DEFAULT_DISCOVERABLE_MODE             GAP_ADTYPE_FLAGS_GENERAL

#ifndef FEATURE_OAD
#define DEFAULT_DESIRED_MIN_CONN_INTERVAL     80 //80=100ms
#define DEFAULT_DESIRED_MAX_CONN_INTERVAL     160
#else //!FEATURE_OAD
#define DEFAULT_DESIRED_MIN_CONN_INTERVAL        8
#define DEFAULT_DESIRED_MAX_CONN_INTERVAL       8
#endif // FEATURE_OAD

// Slave latency to use if automatic parameter update request is enabled
#define DEFAULT_DESIRED_SLAVE_LATENCY           0
#define DEFAULT_DESIRED_CONN_TIMEOUT          200
#define DEFAULT_ENABLE_UPDATE_REQUEST         GAPROLE_LINK_PARAM_UPDATE_INITIATE_BOTH_PARAMS
#define DEFAULT_CONN_PAUSE_PERIPHERAL         2
#define SBP_PERIODIC_EVT_PERIOD               50
#define SBP_DISCONNET_EVT_PERIOD                    100//5000
// Application specific event ID for HCI Connection Event End Events
#define SBP_HCI_CONN_EVT_END_EVT              0x0001

#ifdef FEATURE_OAD
// The size of an OAD packet.
#define OAD_PACKET_SIZE                       ((OAD_BLOCK_SIZE) + 2)
#endif // FEATURE_OAD

// Task configuration
#define SBP_TASK_PRIORITY                     1
#ifndef SBP_TASK_STACK_SIZE
#define SBP_TASK_STACK_SIZE                   2048
#endif

#define SBP_STATE_CHANGE_EVT                  0x0001
#define SBP_CHAR_CHANGE_EVT                   0x0002
// Internal Events for RTOS application
#define SBP_ICALL_EVT                         ICALL_MSG_EVENT_ID // Event_Id_31
#define SBP_QUEUE_EVT                         UTIL_QUEUE_EVENT_ID // Event_Id_30
#define SBP_PERIODIC_EVT                      Event_Id_00
#define SBP_DISCONNET_EVT                      Event_Id_01
#define SBP_UART_QUEUE_EVT                    Event_Id_02

#ifdef FEATURE_OAD
#define SBP_QUEUE_PING_EVT                    Event_Id_01

#define SBP_ALL_EVENTS                        (SBP_ICALL_EVT        | \
                                               SBP_QUEUE_EVT        | \
                                               SBP_UART_QUEUE_EVT   | \
                                               SBP_PERIODIC_EVT     | \
                                               SBP_QUEUE_PING_EVT)
#else
#define SBP_ALL_EVENTS                        (SBP_ICALL_EVT        | \
                                               SBP_QUEUE_EVT        | \
                                               SBP_UART_QUEUE_EVT   | \
                                               SBP_DISCONNET_EVT   | \
                                               SBP_PERIODIC_EVT)
#endif /* FEATURE_OAD */


/*********************************************************************
 * TYPEDEFS
 */
// RTOS queue for profile/app messages.
typedef struct _queueRec_
{
  Queue_Elem _elem;          // queue element
  uint8_t *pData;            // pointer to app data
} queueRec_t;

typedef struct
{
  appEvtHdr_t hdr;  // event header.
} sbpEvt_t;

typedef struct
{
  uint8_t event;  // Type of event
  uint8_t *pData;  // New data
  uint8_t length; // New status
} sbpUARTEvt_t;
/*********************************************************************
 * GLOBAL VARIABLES
 */
bool Uart_empty = true;
uint8_t total_len = 0;
bool ifLOG = false;
bool xiaochengxu = true;
uint8_t num = 0x00;
uint8_t shang = 0x00;
uint8_t yu = 0x00;
uint16 currentMTUSize;
uint8_t Data_send[128] = {0x00,};
extern Ingeek_StateM_t statem;
extern INFO_DATA info_t;
uint8_t valueToCopy[200] = {0};
extern uint16_t gapRole_ConnectionHandle;
extern uint8_t qian_rssi,hou_rssi,zuo_rssi,you_rssi;
uint8_t rssi;
uint8_t BleConnectState;
/*********************************************************************
 * LOCAL VARIABLES
 */
bool DoorState;
bool IfWelcome;
bool AutoLOCK;
bool AutoUnlOCK;
static uint8_t rssi_data[10] = {0};
static int b = 0;
// Entity ID globally used to check for source and/or destination of messages
static ICall_EntityID selfEntity;

// Event globally used to post local events and pend on system and
// local events.
static ICall_SyncHandle syncEvent;

// Clock instances for internal periodic events.
Clock_Struct periodicClock;
Clock_Struct disconnectClock;

// Queue object used for app messages
static Queue_Struct appMsg;
static Queue_Handle appMsgQueue;
// Queue object used for UART messages
static Queue_Struct appUARTMsg;
static Queue_Handle appUARTMsgQueue;

#if defined(FEATURE_OAD)
// Event data from OAD profile.
static Queue_Struct oadQ;
static Queue_Handle hOadQ;
#endif //FEATURE_OAD

// Task configuration
Task_Struct sbpTask;
Char sbpTaskStack[SBP_TASK_STACK_SIZE];

// Profile state and parameters
static gaprole_States_t gapProfileState = GAPROLE_INIT;

// Connection handle of current connection
static uint16_t connHandle = GAP_CONNHANDLE_INIT;

// GAP - SCAN RSP data (max size = 31 bytes)
static uint8_t scanRspData[] =
{
 0x13,   // length of this data
 GAP_ADTYPE_LOCAL_NAME_COMPLETE,
 'i',
 'i',
 'g',
 'e',
 'e',
 'k',
 ' ',
 'D',
 'i',
 'g',
 'i',
 't',
 'a',
 'l',
 ' ',
 'K',
 'e',
 'y',

  // connection interval range
  0x05,   // length of this data
  GAP_ADTYPE_SLAVE_CONN_INTERVAL_RANGE,
  LO_UINT16(DEFAULT_DESIRED_MIN_CONN_INTERVAL),   // 100ms
  HI_UINT16(DEFAULT_DESIRED_MIN_CONN_INTERVAL),
  LO_UINT16(DEFAULT_DESIRED_MAX_CONN_INTERVAL),   // 1s
  HI_UINT16(DEFAULT_DESIRED_MAX_CONN_INTERVAL),

  // Tx power level
  0x02,   // length of this data
  GAP_ADTYPE_POWER_LEVEL,
  0       // 0dBm
};

// GAP - Advertisement data (max size = 31 bytes, though this is
// best kept short to conserve power while advertisting)
static uint8_t advertData[] =
{
  // Flags; this sets the device to use limited discoverable
  // mode (advertises for 30 seconds at a time) instead of general
  // discoverable mode (advertises indefinitely)
  0x02,   // length of this data
  GAP_ADTYPE_FLAGS,
  DEFAULT_DISCOVERABLE_MODE | GAP_ADTYPE_FLAGS_BREDR_NOT_SUPPORTED,

  // service UUID, to notify central devices what services are included
  // in this peripheral
#if !defined(FEATURE_OAD)
  0x03,   // length of this data
#else //OAD for external flash
  0x05,  // length of this data
#endif //FEATURE_OAD
  GAP_ADTYPE_16BIT_MORE,      // some of the UUID's, but not all
#ifdef FEATURE_OAD
  LO_UINT16(OAD_SERVICE_UUID),
  HI_UINT16(OAD_SERVICE_UUID),
#endif //FEATURE_OAD
  LO_UINT16(DKSERVER_SERV_UUID),
  HI_UINT16(DKSERVER_SERV_UUID)
};

// GAP GATT Attributes
static uint8_t attDeviceName[GAP_DEVICE_NAME_LEN] = "Ingeek Digital key";

// Globals used for ATT Response retransmission
static gattMsgEvent_t *pAttRsp = NULL;
static uint8_t rspTxRetry = 0;

/*********************************************************************
 * LOCAL FUNCTIONS
 */

static void SimpleBLEPeripheral_init( void );
static void SimpleBLEPeripheral_taskFxn(UArg a0, UArg a1);
static uint8_t SimpleBLEPeripheral_processStackMsg(ICall_Hdr *pMsg);
static uint8_t SimpleBLEPeripheral_processGATTMsg(gattMsgEvent_t *pMsg);
static void SimpleBLEPeripheral_processAppMsg(sbpEvt_t *pMsg);
static void SimpleBLEPeripheral_processStateChangeEvt(gaprole_States_t newState);
static void SimpleBLEPeripheral_processCharValueChangeEvt(uint8_t paramID);
static void SimpleBLEPeripheral_performPeriodicTask(void);
static void SimpleBLEPeripheral_performDisconnectTask(void);
static void SimpleBLEPeripheral_clockHandler(UArg arg);
static void SimpleBLEPeripheral_sendAttRsp(void);
static void SimpleBLEPeripheral_freeAttRsp(uint8_t status);
static void SimpleBLEPeripheral_stateChangeCB(gaprole_States_t newState);
static void SPPBLEServer_charValueChangeCB(uint8_t paramID);
static void SPPBLEServer_enqueueMsg(uint8_t event, uint8_t state);
void SPPBLEServer_enqueueUARTMsg(uint8_t event, uint8_t *data, uint8_t len);
char* convInt32ToText(int32 value);
#ifdef FEATURE_OAD
void SimpleBLEPeripheral_processOadWriteCB(uint8_t event, uint16_t connHandle,uint8_t *pData);
#endif //FEATURE_OAD

/*********************************************************************
 * EXTERN FUNCTIONS
 */
extern void AssertHandler(uint8 assertCause, uint8 assertSubcause);

/*********************************************************************
 * PROFILE CALLBACKS
 */

// GAP Role Callbacks
static gapRolesCBs_t SimpleBLEPeripheral_gapRoleCBs =
{
  SimpleBLEPeripheral_stateChangeCB     // Profile State Change Callbacks
};

// GAP Bond Manager Callbacks
static gapBondCBs_t simpleBLEPeripheral_BondMgrCBs =
{
  NULL, // Passcode callback (not used by application)
  NULL  // Pairing / Bonding state Callback (not used by application)
};

// Simple GATT Profile Callbacks

static DigitalkeyServiceCBs_t SPPBLEServer_SerialPortService_CBs =
{
  SPPBLEServer_charValueChangeCB // Characteristic value change callback
};


#ifdef FEATURE_OAD
static oadTargetCBs_t simpleBLEPeripheral_oadCBs =
{
  SimpleBLEPeripheral_processOadWriteCB // Write Callback.
};
#endif //FEATURE_OAD

/*********************************************************************
 * PUBLIC FUNCTIONS
 */

/*********************************************************************
 * @fn      SimpleBLEPeripheral_createTask
 *
 * @brief   Task creation function for the Simple BLE Peripheral.
 *
 * @param   None.
 *
 * @return  None.
 */
void SimpleBLEPeripheral_createTask(void)
{
  Task_Params taskParams;

  // Configure task
  Task_Params_init(&taskParams);
  taskParams.stack = sbpTaskStack;
  taskParams.stackSize = SBP_TASK_STACK_SIZE;
  taskParams.priority = SBP_TASK_PRIORITY;

  Task_construct(&sbpTask, SimpleBLEPeripheral_taskFxn, &taskParams, NULL);
}


/*********************************************************************
 * @fn      SimpleBLEPeripheral_init
 *
 * @brief   Called during initialization and contains application
 *          specific initialization (ie. hardware initialization/setup,
 *          table initialization, power up notification, etc), and
 *          profile initialization/setup.
 *
 * @param   None.
 *
 * @return  None.
 */
static void SimpleBLEPeripheral_init(void)
{
#ifdef USE_RCOSC
  RCOSC_enableCalibration();
#endif // USE_RCOSC
  ICall_registerApp(&selfEntity, &syncEvent);
  uint8 bdAddr[] = {0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA};
  HCI_EXT_SetBDADDRCmd(bdAddr);
  appMsgQueue = Util_constructQueue(&appMsg);
  appUARTMsgQueue = Util_constructQueue(&appUARTMsg);
  Util_constructClock(&periodicClock, SimpleBLEPeripheral_clockHandler,
                      SBP_PERIODIC_EVT_PERIOD, 0, false, SBP_PERIODIC_EVT);
  Util_constructClock(&disconnectClock, SimpleBLEPeripheral_clockHandler,
                      SBP_DISCONNET_EVT_PERIOD, 0, false, SBP_DISCONNET_EVT);
  // Setup the GAP
  GAP_SetParamValue(TGAP_CONN_PAUSE_PERIPHERAL, DEFAULT_CONN_PAUSE_PERIPHERAL);
  // Setup the GAP Peripheral Role Profile
  {
    uint8_t initialAdvertEnable = TRUE;
    uint16_t advertOffTime = 0;
    uint8_t enableUpdateRequest = DEFAULT_ENABLE_UPDATE_REQUEST;
    uint16_t desiredMinInterval = DEFAULT_DESIRED_MIN_CONN_INTERVAL;
    uint16_t desiredMaxInterval = DEFAULT_DESIRED_MAX_CONN_INTERVAL;
    uint16_t desiredSlaveLatency = DEFAULT_DESIRED_SLAVE_LATENCY;
    uint16_t desiredConnTimeout = DEFAULT_DESIRED_CONN_TIMEOUT;

    GAPRole_SetParameter(GAPROLE_ADVERT_ENABLED, sizeof(uint8_t),&initialAdvertEnable);
    GAPRole_SetParameter(GAPROLE_ADVERT_OFF_TIME, sizeof(uint16_t),&advertOffTime);
    GAPRole_SetParameter(GAPROLE_SCAN_RSP_DATA, sizeof(scanRspData),scanRspData);
    GAPRole_SetParameter(GAPROLE_ADVERT_DATA, sizeof(advertData), advertData);
    GAPRole_SetParameter(GAPROLE_PARAM_UPDATE_ENABLE, sizeof(uint8_t),&enableUpdateRequest);
    GAPRole_SetParameter(GAPROLE_MIN_CONN_INTERVAL, sizeof(uint16_t),&desiredMinInterval);
    GAPRole_SetParameter(GAPROLE_MAX_CONN_INTERVAL, sizeof(uint16_t),&desiredMaxInterval);
    GAPRole_SetParameter(GAPROLE_SLAVE_LATENCY, sizeof(uint16_t),&desiredSlaveLatency);
    GAPRole_SetParameter(GAPROLE_TIMEOUT_MULTIPLIER, sizeof(uint16_t),&desiredConnTimeout);
  }

  // Set the GAP Characteristics
  GGS_SetParameter(GGS_DEVICE_NAME_ATT, GAP_DEVICE_NAME_LEN, attDeviceName);
  // Set advertising interval
  {
    uint16_t advInt = DEFAULT_ADVERTISING_INTERVAL;
    GAP_SetParamValue(TGAP_LIM_DISC_ADV_INT_MIN, advInt);
    GAP_SetParamValue(TGAP_LIM_DISC_ADV_INT_MAX, advInt);
    GAP_SetParamValue(TGAP_GEN_DISC_ADV_INT_MIN, advInt);
    GAP_SetParamValue(TGAP_GEN_DISC_ADV_INT_MAX, advInt);
  }

  // Setup the GAP Bond Manager
  {
    uint32_t passkey = 0; // passkey "000000"
    uint8_t pairMode = GAPBOND_PAIRING_MODE_WAIT_FOR_REQ;
    uint8_t mitm = TRUE;
    uint8_t ioCap = GAPBOND_IO_CAP_DISPLAY_ONLY;
    uint8_t bonding = TRUE;

    GAPBondMgr_SetParameter(GAPBOND_DEFAULT_PASSCODE, sizeof(uint32_t),&passkey);
    GAPBondMgr_SetParameter(GAPBOND_PAIRING_MODE, sizeof(uint8_t), &pairMode);
    GAPBondMgr_SetParameter(GAPBOND_MITM_PROTECTION, sizeof(uint8_t), &mitm);
    GAPBondMgr_SetParameter(GAPBOND_IO_CAPABILITIES, sizeof(uint8_t), &ioCap);
    GAPBondMgr_SetParameter(GAPBOND_BONDING_ENABLED, sizeof(uint8_t), &bonding);
  }

   // Initialize GATT attributes
  GGS_AddService(GATT_ALL_SERVICES);           // GAP
  GATTServApp_AddService(GATT_ALL_SERVICES);   // GATT attributes
  DevInfo_AddService();                        // Device Information Service
  DigitalkeyService_AddService(GATT_ALL_SERVICES);

#ifdef FEATURE_OAD
  VOID OAD_addService();
  OAD_register((oadTargetCBs_t *)&simpleBLEPeripheral_oadCBs);
  hOadQ = Util_constructQueue(&oadQ);
#endif

#ifdef IMAGE_INVALIDATE
  Reset_addService();
#endif

  DigitalkeyService_RegisterAppCBs(&SPPBLEServer_SerialPortService_CBs);
  VOID GAPRole_StartDevice(&SimpleBLEPeripheral_gapRoleCBs);
  VOID GAPBondMgr_Register(&simpleBLEPeripheral_BondMgrCBs);
  GAP_RegisterForMsgs(selfEntity);
  GATT_RegisterForMsgs(selfEntity);
  SDITask_registerIncomingRXEventAppCB(SPPBLEServer_enqueueUARTMsg);
  //uint8_t hello[] = "Hello from dazhong BLE Server! With Data Length Extension support!\n\r";
  //DEBUG(hello);

  //#define APP_SUGGESTED_PDU_SIZE 251
  //#define APP_SUGGESTED_TX_TIME 2120
  //This API is documented in hci.h
  //HCI_LE_WriteSuggestedDefaultDataLenCmd(APP_SUGGESTED_PDU_SIZE ,APP_SUGGESTED_TX_TIME);
  Check_Carinfo();
  HCI_EXT_SetTxPowerCmd(LL_EXT_TX_POWER_5_DBM);
}

/*********************************************************************
 * @fn      SimpleBLEPeripheral_taskFxn
 *
 * @brief   Application task entry point for the Simple BLE Peripheral.
 *
 * @param   a0, a1 - not used.
 *
 * @return  None.
 */
static void SimpleBLEPeripheral_taskFxn(UArg a0, UArg a1)
{
  // Initialize application
  SimpleBLEPeripheral_init();

  // Application main loop
  for (;;)
  {
    uint32_t events;
    events = Event_pend(syncEvent, Event_Id_NONE, SBP_ALL_EVENTS,ICALL_TIMEOUT_FOREVER);
    if (events)
    {
      ICall_EntityID dest;
      ICall_ServiceEnum src;
      ICall_HciExtEvt *pMsg = NULL;

      if (ICall_fetchServiceMsg(&src, &dest,
                                (void **)&pMsg) == ICALL_ERRNO_SUCCESS)
      {
        uint8 safeToDealloc = TRUE;

        if ((src == ICALL_SERVICE_CLASS_BLE) && (dest == selfEntity))
        {
          ICall_Stack_Event *pEvt = (ICall_Stack_Event *)pMsg;

          // Check for BLE stack events first
          if (pEvt->signature == 0xffff)
          {
            if (pEvt->event_flag & SBP_HCI_CONN_EVT_END_EVT)
            {
              // Try to retransmit pending ATT Response (if any)
              SimpleBLEPeripheral_sendAttRsp();
            }
          }
          else
          {
            // Process inter-task message
            safeToDealloc = SimpleBLEPeripheral_processStackMsg((ICall_Hdr *)pMsg);
          }
        }

        if (pMsg && safeToDealloc)
        {
          ICall_freeMsg(pMsg);
        }
      }

      // If RTOS queue is not empty, process app message.
      if (events & SBP_UART_QUEUE_EVT)
      {
        // If RTOS queue is not empty, process app message.
        if (!Queue_empty(appUARTMsgQueue))
        {
          //Get the message at the front of the queue but still keep it in the queue
          queueRec_t *pRec = Queue_head(appUARTMsgQueue);
          sbpUARTEvt_t *pMsg = (sbpUARTEvt_t *)pRec->pData;

          if (pMsg)
          {
            bStatus_t retVal = FAILURE;

            switch(pMsg->event)
            {
            case SBP_UART_DATA_EVT:
              {
                      //Send the notification
                      //retVal = SerialPortService_SetParameter(SERIALPORTSERVICE_CHAR_DATA, pMsg->length, pMsg->pData);
                  if(Uart_empty == false){
                      memcpy(valueToCopy+total_len, pMsg->pData, pMsg->length);
                  }else{
                      memset(valueToCopy, 0x00, 200);
                      memcpy(valueToCopy, pMsg->pData, pMsg->length);
                  }

                //Remove from queue
                Util_dequeueMsg(appUARTMsgQueue);
                //Deallocate data payload being transmitted.
                ICall_freeMsg(pMsg->pData);
                // Free the space from the message.
                ICall_free(pMsg);

                if(!Queue_empty(appUARTMsgQueue))
                {
                    Uart_empty =false;
                    // Wake up the application to flush out any remaining UART data in the queue.
                    Event_post(syncEvent, SBP_UART_QUEUE_EVT);
                }else{
                    Uart_empty =true;
                }
                total_len +=(pMsg->length);

  if(Uart_empty == true){
#ifdef DATA_PASSTHROUGH
      uint8_t info_data[7] = {0x7E,0x10,0x10,0x02,0xFF,0xF2,0x1E};
      uint8_t status_data[7] = {0x7E,0x10,0x10,0x02,0xFF,0xF1,0x01};
      //uint8_t data_header[7] = {0};
      //SDITask_sendToUART(&total_len, 1);
      //SDITask_sendToUART(valueToCopy, total_len);
      //memcpy(data_header, valueToCopy, 7);
      if(valueToCopy[5] == 0xF2){
          //uint8_t status = valueToCopy[7];//CARINFO_VALID;
          //UART_WriteTransport (info_data, 7);
          //DEBUG("55555");
          statem.status = 0x00;
          retVal = DigitalkeyService_SetParameter(DKSERVER_CHAR_STATUS,&(statem.status),sizeof(uint8_t));
          info_t.infolen = 29;
          info_t.flag = SUCCESS;
          memcpy(info_t.info_data, valueToCopy+8, 29);
      }else if(valueToCopy[5] == 0xF1){
          //DEBUG("44444");
          statem.status = valueToCopy[7];
          retVal = DigitalkeyService_SetParameter(DKSERVER_CHAR_STATUS,&(statem.status),sizeof(uint8_t));
      }else if(valueToCopy[5] == 0xF4){
          //DEBUG("44444");
          statem.status = valueToCopy[7];
          retVal = DigitalkeyService_SetParameter(DKSERVER_CHAR_STATUS,&(statem.status),sizeof(uint8_t));
          DigitalkeyService_SetParameter(DKSERVER_CHAR_SESSION, valueToCopy+8, 112);
      }else if(valueToCopy[5] == 0xF5){
         // retVal = DigitalkeyService_SetParameter(DKSERVER_CHAR_STATUS,&(statem.status),sizeof(uint8_t));
          DigitalkeyService_SetParameter(DKSERVER_CHAR_CMD, valueToCopy+7, 16);
      }
      total_len = 0;
#else
 //if(((gapProfileState == GAPROLE_CONNECTED) || (gapProfileState == GAPROLE_CONNECTED_ADV))){

   if(total_len > 0){
       //DEBUG("total_len > 0");
       uint8_t car_status[7] = {0x7E,0x10,0x50,0x04,0xFF,0xF4};
       char CAR_REQ[] = "AT+CAR_REQ\r\n";
       char FOB_REQ[] = "AT+FOB_REQ\r\n";
       char GET_RSSI[] = "AT+GET_RSSI\r\n";
       char OPEN_DEBUG[] = "AT+OPEN_DEBUG\r\n";
       char CLOSE_DEBUG[] = "AT+CLOSE_DEBUG\r\n";
       if(memcmp(car_status, valueToCopy, 6)){
           DigitalkeyService_SetParameter(DKSERVER_CHAR_SESSION, valueToCopy+6, total_len-6);
       }
//   定位串口测试代码
       uint8_t qian_num = valueToCopy[0];
       uint8_t hou_num = valueToCopy[1];
       uint8_t zuo_num = valueToCopy[2];
       uint8_t you_num = valueToCopy[3];
       uint8_t total = qian_num+hou_num+zuo_num+you_num;
       //DEBUG("total_len:"); DEBUG((uint8_t*)convInt32ToText((int)total_len)); DEBUG_NEWLINE();
       //if(total == (total_len-4) ){
           //DEBUG(valueToCopy);
           qian_rssi = 70;//meansDoRssi(valueToCopy+4, qian_num);
           //DEBUG("qian_rssi:"); DEBUG((uint8_t*)convInt32ToText((int)qian_rssi)); //DEBUG_NEWLINE();
           hou_rssi = 70;//meansDoRssi(valueToCopy+4+qian_num, hou_num);
           //DEBUG("hou_rssi:"); DEBUG((uint8_t*)convInt32ToText((int)hou_rssi)); //DEBUG_NEWLINE();
           zuo_rssi = 70;//meansDoRssi(valueToCopy+4+qian_num+hou_num, zuo_num);
           //DEBUG("zuo_rssi:"); DEBUG((uint8_t*)convInt32ToText((int)zuo_rssi)); //DEBUG_NEWLINE();
           you_rssi = 70;//meansDoRssi(valueToCopy+4+qian_num+hou_num+zuo_num, you_num);
           //DEBUG("you_rssi:"); DEBUG((uint8_t*)convInt32ToText((int)you_rssi)); DEBUG_NEWLINE();
       //}

       if (strcmp(CAR_REQ, (char*)valueToCopy) == 0){
                  if(statem.status==WRITE_SESSION){
                      //if((rssi<qian_rssi)&&(rssi<hou_rssi)&&(rssi<zuo_rssi)&&(rssi<you_rssi)){
                      if(rssi<60){
#ifdef DATA_PASSTHROUGH
                                    //DEBUG("AT+OUTCAR\r\n");
#else
                                    //DEBUG("AT+OUTCAR\r\n");
                                    DEBUG("AT+INCAR\r\n");
#endif
                      }else{
#ifdef DATA_PASSTHROUGH
                                    //DEBUG("AT+INCAR\r\n");
#else
                                    DEBUG("AT+OUTCAR\r\n");
                                    //DEBUG("AT+INCAR\r\n");
#endif
                      }
                  }else{
                      DEBUG("AT+FOB_NO\r\n");
                  }
                  //DigitalkeyService_SetParameter(DKSERVER_CHAR_CMD, CMD,1);
       } if (strcmp(FOB_REQ, (char*)valueToCopy) == 0){
           if(statem.status==WRITE_SESSION){
           //DEBUG("AT+FOB_FIND\r\n");
           DEBUG("AT+CONNECT\r\n");
           }else{
           //DEBUG("AT+FOB_NO\r\n");
           DEBUG("AT++DISCONNECT\r\n");
           }
           //DigitalkeyService_SetParameter(DKSERVER_CHAR_CMD, CMD,1);
       }else if (strcmp(GET_RSSI, (char*)valueToCopy) == 0){
           if(statem.status==WRITE_SESSION){
               uint8_t buffer[1]={9};
               DigitalkeyService_SetParameter(DKSERVER_CHAR_CMD, buffer, 1);
           }else{
               DEBUG("AT+rssi_no\r\n");
           }
         }else if (strcmp(OPEN_DEBUG, (char*)valueToCopy) == 0){
             ifLOG = true;
             DEBUG("AT+OPEN_DEBUG\r\n");
         }else if (strcmp(CLOSE_DEBUG, (char*)valueToCopy) == 0){
             ifLOG = false;
             DEBUG("AT+CLOSE_DEBUG\r\n");
         }
           total_len = 0;
       }
#endif
  }
                break;
              }
            default:
              break;
            }
          }
        }
      }

      // If RTOS queue is not empty, process app message.
      if (events & SBP_QUEUE_EVT)
      {
        while (!Queue_empty(appMsgQueue))
        {
          sbpEvt_t *pMsg = (sbpEvt_t *)Util_dequeueMsg(appMsgQueue);
          if (pMsg)
          {
            // Process message.
            SimpleBLEPeripheral_processAppMsg(pMsg);

            // Free the space from the message.
            ICall_free(pMsg);
          }
        }
      }

      if (events & SBP_PERIODIC_EVT)
      {
        Util_startClock(&periodicClock);

        // Perform periodic application task
        SimpleBLEPeripheral_performPeriodicTask();
      }

      if (events & SBP_DISCONNET_EVT)
      {
        Util_startClock(&disconnectClock);

        // Perform periodic application task
        SimpleBLEPeripheral_performDisconnectTask();
      }
#ifdef FEATURE_OAD
      if (events & SBP_QUEUE_PING_EVT)
      {
        while (!Queue_empty(hOadQ))
        {
          oadTargetWrite_t *oadWriteEvt = Queue_get(hOadQ);

          // Identify new image.
          if (oadWriteEvt->event == OAD_WRITE_IDENTIFY_REQ)
          {
            OAD_imgIdentifyWrite(oadWriteEvt->connHandle, oadWriteEvt->pData);
          }
          // Write a next block request.
          else if (oadWriteEvt->event == OAD_WRITE_BLOCK_REQ)
          {
            OAD_imgBlockWrite(oadWriteEvt->connHandle, oadWriteEvt->pData);
          }

          // Free buffer.
          ICall_free(oadWriteEvt);
        }
      }
#endif //FEATURE_OAD
    }
  }
}

#if DBG_KALMAN_FILTER

static double Q = 0.001f;        // 过程方差，反应两个时刻加速度方差
static double R = 0.1f;         // 测量方差，反应温度计的测量精度

static double xhatminus;     // 加速度的先验估计，在k-1时刻，对k时刻加速的做出估计
static double rssi_pre = 0;      // k-1时刻的采样值
static double rssi_deal_end;
static double Pminus;        // 先验估计的方差
static double P_pre;         // 上一时刻加速度最优估计值的方差
static double K;             // 卡尔曼增益,反应加速计测量结果与过程模型（即当前时刻与下一时刻加速计相同这一模型）的可信程度
static double PP;            // 误差方差

/**
 * fn:      kalmanFilteringDoRssi
 * brief:   对采集的rssi信号进行卡尔曼滤波处理
 * prama:   rssi - 采集到的信号强度
 * return:  rssi_deal_end - 卡尔曼滤波完成的信号强度
 */

double kalmanFilteringDoRssi(double rssi)
{
    rssi_deal_end = rssi;
    xhatminus = rssi_pre;
    // 预测的方差为上一时刻加速度最优估计值得方差与过程方差之和
    Pminus = P_pre + Q;
    //卡尔曼增益,反应加速计测量结果与过程模型（即当前时刻与下一时刻加速计相同这一模型）的可信程度
    K = Pminus / (Pminus + R);
    //结合当前的测量值，对上一时刻的预测进行校正，得到校正后的最优估计，该估计具有最小均方差
    rssi_deal_end = xhatminus + K * (rssi_deal_end - xhatminus);
    //计算最终估计值得方差
    PP = (1 - K) * Pminus;
    rssi_pre = rssi_deal_end;
    //DBG_LOG("rssi_deal_end = %.3f rssi_pre = %.3f" , rssi_deal_end, rssi_pre);
    P_pre = PP;

    return rssi_deal_end;

}
/**
 *  fn:         bubblesort
 *  brief:      冒泡法排序
 *  prama:      data - 需要排序的数组地址
 *              len - 数据的实际长度
 */
void bubblesort(uint8_t a[], uint8_t n)
{
    int i;
    int j;//控制单个冒泡的变量
    int maxer;
    /*循环控制“冒泡”的次数，比数组个数少一个*/
    for(i=n-2;i>=0;i--){
        for(j=0;j<=i;j++){
            maxer=a[j];
            if(maxer>=a[j+1]){
                /*如果前面的数比后面的数大，交换顺序*/
                a[j]=a[j+1];
                a[j+1]=maxer;
            }
        }
    }
}

/**
 * fn:      meansDoRssi
 * brief：   对采集的rssi信号进行加权均值滤波
 * prama：   bleNodeInfo - 采集的id和rssi信息
 * return:  dealEndRssi - 处理完成的rssi信息
 */

int meansDoRssi(uint8_t *bleNodeInfo, uint8_t len)
{
    int rssiTmp = 0, dealEndRssi = 0;
    int i = 0, actualCollectNumber = 0;

    bubblesort(bleNodeInfo, len);

    for(i = 0; i < len; i++)
    {
        rssiTmp += bleNodeInfo[i];
        //actualCollectNumber++;
        //bleNodeInfo[i] = 0;
    }
    //rssiTmp = bleNodeInfo[1]+bleNodeInfo[2]+bleNodeInfo[3]+bleNodeInfo[4]+bleNodeInfo[5]+bleNodeInfo[6]+bleNodeInfo[7]+bleNodeInfo[8];
    dealEndRssi = rssiTmp/len;
    rssiTmp = 0;
    return dealEndRssi;
}
#endif
/*********************************************************************
 * @fn      SimpleBLEPeripheral_processStackMsg
 *
 * @brief   Process an incoming stack message.
 *
 * @param   pMsg - message to process
 *
 * @return  TRUE if safe to deallocate incoming message, FALSE otherwise.
 */
static uint8_t SimpleBLEPeripheral_processStackMsg(ICall_Hdr *pMsg)
{
  uint8_t safeToDealloc = TRUE;

  switch (pMsg->event)
  {
    case GATT_MSG_EVENT:
      // Process GATT message
      safeToDealloc = SimpleBLEPeripheral_processGATTMsg((gattMsgEvent_t *)pMsg);
      break;

    case HCI_GAP_EVENT_EVENT:
      {
        // Process HCI message
        switch(pMsg->status)
        {
        case HCI_COMMAND_COMPLETE_EVENT_CODE:
          // Process HCI Command Complete Event
            // Parse Command Complete Event for opcode and status
            hciEvt_CmdComplete_t* command_complete = (hciEvt_CmdComplete_t*)pMsg;
            uint8_t status = command_complete->pReturnParam[0];
            //find which command this command complete is for
            switch (command_complete->cmdOpcode)
            {
                case HCI_READ_RSSI:
                {
                    if (status == SUCCESS){
                        uint16_t handle = BUILD_UINT16( command_complete->pReturnParam[2], command_complete->pReturnParam[1]);
                        //check handle
                        if (handle == gapRole_ConnectionHandle){
                            uint8_t temp_rssi = command_complete->pReturnParam[3];
                            temp_rssi = 0 - temp_rssi;
                            //DEBUG("temp_rssi:");
                            //DEBUG((uint8_t*)convInt32ToText((int)temp_rssi)); //DEBUG_NEWLINE();
#if DBG_KALMAN_FILTER
                            double rssivalue = kalmanFilteringDoRssi((double)temp_rssi);
                            temp_rssi = (uint8_t)rssivalue;
                            //DEBUG("kalman_rssi:");
                            //DEBUG(",");DEBUG((uint8_t*)convInt32ToText((int)temp_rssi)); DEBUG_NEWLINE();
                            rssi_data[b] = temp_rssi;
                            if(b >= 1){
                            //a[b] = (a[b]+a[b-1])/2;
                            }
                            b++;
                            //DEBUG("RSSI:"); DEBUG((uint8_t*)convInt32ToText((int)rssi)); DEBUG_NEWLINE();
                            if(b ==10){
                                rssi = meansDoRssi(rssi_data, 10);
                                //DEBUG("rssi:");DEBUG((uint8_t*)convInt32ToText((int)rssi)); DEBUG_NEWLINE();
                                b = 0;
                                if(rssi > 80){
                                    AutoUnlOCK = true;
                                    IfWelcome = true;
                                }else if(rssi < 70){
                                    AutoLOCK = true;
                                    IfWelcome = false;
                                }

                                if((AutoUnlOCK == true)&&(statem.status == WRITE_SESSION)&&(rssi < 75)&&(DoorState == true)&&(IfWelcome == true)){
                                    DEBUG("AT+WELCOME\r\n");
                                    IfWelcome = false;
                                }

                                if((AutoUnlOCK == true)&&(statem.status == WRITE_SESSION)&&(rssi < 70)&&(DoorState == true)){
                                    DEBUG("AT+UNLOCK\r\n");
                                    DoorState = false;
                                    AutoLOCK = true;
                                }else if((AutoLOCK == true)&&(statem.status == WRITE_SESSION)&&(rssi > 80)&&(DoorState == false)){
                                    DEBUG("AT+LOCK\r\n");
                                    DoorState = true;
                                    AutoUnlOCK = true;
                                }
                                memset(rssi_data, 0, 10);
                            }

#else
                            DEBUG("rssi:"); DEBUG((uint8_t*)convInt32ToText((int)rssi)); DEBUG_NEWLINE();
#endif
                        }
                    }
                }
            }
          break;

          case HCI_BLE_HARDWARE_ERROR_EVENT_CODE:
            AssertHandler(HAL_ASSERT_CAUSE_HARDWARE_ERROR,0);
            break;

          default:
            break;
        }
      }
      break;

    default:
      // do nothing
      break;
  }

  return (safeToDealloc);
}

/*********************************************************************
 * @fn      SimpleBLEPeripheral_processGATTMsg
 *
 * @brief   Process GATT messages and events.
 *
 * @return  TRUE if safe to deallocate incoming message, FALSE otherwise.
 */
static uint8_t SimpleBLEPeripheral_processGATTMsg(gattMsgEvent_t *pMsg)
{
  // See if GATT server was unable to transmit an ATT response
  if (pMsg->hdr.status == blePending)
  {
    // No HCI buffer was available. Let's try to retransmit the response
    // on the next connection event.
    if (HCI_EXT_ConnEventNoticeCmd(pMsg->connHandle, selfEntity,
                                   SBP_HCI_CONN_EVT_END_EVT) == SUCCESS)
    {
      // First free any pending response
      SimpleBLEPeripheral_freeAttRsp(FAILURE);

      // Hold on to the response message for retransmission
      pAttRsp = pMsg;

      // Don't free the response message yet
      return (FALSE);
    }
  }
  else if (pMsg->method == ATT_FLOW_CTRL_VIOLATED_EVENT)
  {
    // ATT request-response or indication-confirmation flow control is
    // violated. All subsequent ATT requests or indications will be dropped.
    // The app is informed in case it wants to drop the connection.

    // Display the opcode of the message that caused the violation.
    //Display_print1(dispHandle, 5, 0, "FC Violated: %d", pMsg->msg.flowCtrlEvt.opcode);
  }
  else if (pMsg->method == ATT_MTU_UPDATED_EVENT)
  {
    // MTU size updated
    currentMTUSize = pMsg->msg.mtuEvt.MTU;
    xiaochengxu = false;
    //SDITask_setAppDataSize(currentMTUSize);
    if(true == ifLOG){
        DEBUG("MTU Size: "); DEBUG((uint8_t*)convInt32ToText((int)currentMTUSize)); DEBUG_NEWLINE();
    }
  }

  // Free message payload. Needed only for ATT Protocol messages
  GATT_bm_free(&pMsg->msg, pMsg->method);

  // It's safe to free the incoming message
  return (TRUE);
}

/*********************************************************************
 * @fn      SimpleBLEPeripheral_sendAttRsp
 *
 * @brief   Send a pending ATT response message.
 *
 * @param   none
 *
 * @return  none
 */
static void SimpleBLEPeripheral_sendAttRsp(void)
{
  // See if there's a pending ATT Response to be transmitted
  if (pAttRsp != NULL)
  {
    uint8_t status;

    // Increment retransmission count
    rspTxRetry++;

    // Try to retransmit ATT response till either we're successful or
    // the ATT Client times out (after 30s) and drops the connection.
    status = GATT_SendRsp(pAttRsp->connHandle, pAttRsp->method, &(pAttRsp->msg));
    if ((status != blePending) && (status != MSG_BUFFER_NOT_AVAIL))
    {
      // Disable connection event end notice
      HCI_EXT_ConnEventNoticeCmd(pAttRsp->connHandle, selfEntity, 0);

      // We're done with the response message
      SimpleBLEPeripheral_freeAttRsp(status);
    }
    else
    {
      // Continue retrying
      //Display_print1(dispHandle, 5, 0, "Rsp send retry: %d", rspTxRetry);
    }
  }
}

/*********************************************************************
 * @fn      SimpleBLEPeripheral_freeAttRsp
 *
 * @brief   Free ATT response message.
 *
 * @param   status - response transmit status
 *
 * @return  none
 */
static void SimpleBLEPeripheral_freeAttRsp(uint8_t status)
{
  // See if there's a pending ATT response message
  if (pAttRsp != NULL)
  {
    // See if the response was sent out successfully
    if (status == SUCCESS)
    {
      ;//Display_print1(dispHandle, 5, 0, "Rsp sent retry: %d", rspTxRetry);
    }
    else
    {
      // Free response payload
      GATT_bm_free(&pAttRsp->msg, pAttRsp->method);
    }

    // Free response message
    ICall_freeMsg(pAttRsp);

    // Reset our globals
    pAttRsp = NULL;
    rspTxRetry = 0;
  }
}

/*********************************************************************
 * @fn      SimpleBLEPeripheral_processAppMsg
 *
 * @brief   Process an incoming callback from a profile.
 *
 * @param   pMsg - message to process
 *
 * @return  None.
 */
static void SimpleBLEPeripheral_processAppMsg(sbpEvt_t *pMsg)
{
  switch (pMsg->hdr.event)
  {
    case SBP_STATE_CHANGE_EVT:
      SimpleBLEPeripheral_processStateChangeEvt((gaprole_States_t)pMsg->
                                                hdr.state);
      break;
    case SBP_CHAR_CHANGE_EVT:
      SimpleBLEPeripheral_processCharValueChangeEvt(pMsg->hdr.state);
      break;

    default:
      // Do nothing.
      break;
  }
}

/*********************************************************************
 * @fn      SimpleBLEPeripheral_stateChangeCB
 *
 * @brief   Callback from GAP Role indicating a role state change.
 *
 * @param   newState - new state
 *
 * @return  None.
 */
static void SimpleBLEPeripheral_stateChangeCB(gaprole_States_t newState)
{
  SPPBLEServer_enqueueMsg(SBP_STATE_CHANGE_EVT, newState);
}

/*********************************************************************
 * @fn      SimpleBLEPeripheral_processStateChangeEvt
 *
 * @brief   Process a pending GAP Role state change event.
 *
 * @param   newState - new state
 *
 * @return  None.
 */
static void SimpleBLEPeripheral_processStateChangeEvt(gaprole_States_t newState)
{
#ifdef PLUS_BROADCASTER
  static bool firstConnFlag = false;
#endif // PLUS_BROADCASTER

  switch ( newState )
  {
    case GAPROLE_STARTED:
      {
        uint8_t ownAddress[B_ADDR_LEN];
        uint8_t systemId[DEVINFO_SYSTEM_ID_LEN];

        GAPRole_GetParameter(GAPROLE_BD_ADDR, ownAddress);

        // use 6 bytes of device address for 8 bytes of system ID value
        systemId[0] = ownAddress[0];
        systemId[1] = ownAddress[1];
        systemId[2] = ownAddress[2];

        // set middle bytes to zero
        systemId[4] = 0x00;
        systemId[3] = 0x00;

        // shift three bytes up
        systemId[7] = ownAddress[5];
        systemId[6] = ownAddress[4];
        systemId[5] = ownAddress[3];
        DevInfo_SetParameter(DEVINFO_SYSTEM_ID, DEVINFO_SYSTEM_ID_LEN, systemId);
      }
      break;

    case GAPROLE_ADVERTISING:
#ifdef DATA_PASSTHROUGH
        uint8_t adver[6] = {0x7E, 0x01, 0x01, 0x01, 0xFF, 0xFF};
        SDITask_sendToUART(adver, 6);
#else
        DEBUG("AT+ADVERTISING\r\n");
#endif
      break;

#ifdef PLUS_BROADCASTER

    /* After a connection is dropped a device in PLUS_BROADCASTER will continue
     * sending non-connectable advertisements and shall sending this change of
     * state to the application.  These are then disabled here so that sending
     * connectable advertisements can resume.
     */

    case GAPROLE_ADVERTISING_NONCONN:
      {
        uint8_t advertEnabled = FALSE;

        // Disable non-connectable advertising.
        GAPRole_SetParameter(GAPROLE_ADV_NONCONN_ENABLED, sizeof(uint8_t),
                           &advertEnabled);

        advertEnabled = TRUE;

        // Enabled connectable advertising.
        GAPRole_SetParameter(GAPROLE_ADVERT_ENABLED, sizeof(uint8_t),
                             &advertEnabled);

        // Reset flag for next connection.
        firstConnFlag = false;

        SimpleBLEPeripheral_freeAttRsp(bleNotConnected);
      }
      break;
#endif //PLUS_BROADCASTER

    case GAPROLE_CONNECTED:
      {
        linkDBInfo_t linkInfo;
        uint8_t numActive = 0;

        //Util_startClock(&periodicClock);
        Util_startClock(&disconnectClock);
        numActive = linkDB_NumActive();
        connHandle = numActive - 1;
        // Use numActive to determine the connection handle of the last
        // connection
        if ( linkDB_GetInfo( numActive - 1, &linkInfo ) == SUCCESS )
        {
#ifdef DATA_PASSTHROUGH
      //uint8_t disconnet[6] = {0x7E, 0x01, 0x03, 0x01, 0xFF, 0xFF};
      //SDITask_sendToUART(disconnet, 6);
#else
            DEBUG("AT+CONNECTED\r\n");
#endif

        }
        else
        {
          uint8_t peerAddress[B_ADDR_LEN];
          GAPRole_GetParameter(GAPROLE_CONN_BD_ADDR, peerAddress);
#ifdef DATA_PASSTHROUGH
      //uint8_t disconnet[6] = {0x7E, 0x01, 0x03, 0x01, 0xFF, 0xFF};
      //SDITask_sendToUART(disconnet, 6);
#else
            DEBUG("AT+CONNECTED\r\n");
#endif
        }

        //Request max supported size
        #define APP_SUGGESTED_PDU_SIZE 251
        #define APP_SUGGESTED_TX_TIME 2120
        uint16_t requestedPDUSize = APP_SUGGESTED_PDU_SIZE;
        uint16_t requestedTxTime = APP_SUGGESTED_TX_TIME;

        //This API is documented in hci.h
        if(SUCCESS != HCI_LE_SetDataLenCmd(connHandle, requestedPDUSize, requestedTxTime))
        {
            if(ifLOG){
                DEBUG("Data length update failed");
            }
        }else{
            if(ifLOG){
                DEBUG("Data length update success");
            }
        }

        #ifdef PLUS_BROADCASTER
          // Only turn advertising on for this state when we first connect
          // otherwise, when we go from connected_advertising back to this state
          // we will be turning advertising back on.
          if (firstConnFlag == false)
          {
            uint8_t advertEnabled = FALSE; // Turn on Advertising

            // Disable connectable advertising.
            GAPRole_SetParameter(GAPROLE_ADVERT_ENABLED, sizeof(uint8_t),
                                 &advertEnabled);

            // Set to true for non-connectabel advertising.
            advertEnabled = TRUE;

            // Enable non-connectable advertising.
            GAPRole_SetParameter(GAPROLE_ADV_NONCONN_ENABLED, sizeof(uint8_t),
                                 &advertEnabled);
            firstConnFlag = true;
          }
        #endif // PLUS_BROADCASTER
      }
      break;

    case GAPROLE_CONNECTED_ADV:
      ;//Display_print0(dispHandle, 2, 0, "Connected Advertising");
      break;

    case GAPROLE_WAITING:
#ifdef DATA_PASSTHROUGH
      //uint8_t disconnet[6] = {0x7E, 0x01, 0x03, 0x01, 0xFF, 0xFF};
      //SDITask_sendToUART(disconnet, 6);
#else
      DEBUG("AT+DISCONNECTED\r\n");
      BleConnectState = 0;
#endif
      xiaochengxu = true;
      Util_stopClock(&periodicClock);
      SimpleBLEPeripheral_freeAttRsp(bleNotConnected);
      if(statem.status != CARINFO_INVALID){
          statem.status=CARINFO_VALID;
          DigitalkeyService_SetParameter(DKSERVER_CHAR_STATUS,&(statem.status),sizeof(uint8_t));
      }

      break;

    case GAPROLE_WAITING_AFTER_TIMEOUT:
#ifdef DATA_PASSTHROUGH
        uint8_t discon[6] = {0x7E, 0x01, 0x03, 0x01, 0xFF, 0xFF};
        SDITask_sendToUART(discon, 6);
#else
        DEBUG("AT+DISCONNECTED AFTER TIMEOUT\r\n");
#endif
      xiaochengxu = true;
      Util_stopClock(&periodicClock);
      SimpleBLEPeripheral_freeAttRsp(bleNotConnected);

      if(statem.status != CARINFO_INVALID){
          statem.status=CARINFO_VALID;
          DigitalkeyService_SetParameter(DKSERVER_CHAR_STATUS,&(statem.status),sizeof(uint8_t));
      }
      #ifdef PLUS_BROADCASTER
        // Reset flag for next connection.
        firstConnFlag = false;
      #endif //#ifdef (PLUS_BROADCASTER)
      break;

    case GAPROLE_ERROR:
      ;//Display_print0(dispHandle, 2, 0, "Error");
      break;

    default:
      break;
  }

  // Update the state
  gapProfileState = newState;
}

/*********************************************************************
 * @fn      SPPBLEServer_charValueChangeCB
 *
 * @brief   Callback from Simple Profile indicating a characteristic
 *          value change.
 *
 * @param   paramID - parameter ID of the value that was changed.
 *
 * @return  None.
 */
static void SPPBLEServer_charValueChangeCB(uint8_t paramID)
{
  SPPBLEServer_enqueueMsg(SBP_CHAR_CHANGE_EVT, paramID);
}

/*********************************************************************
 * @fn      SimpleBLEPeripheral_performPeriodicTask
 *
 * @brief   Perform a periodic application task. This function gets called
 *          every five seconds (SBP_PERIODIC_EVT_PERIOD). In this example,
 *          the value of the third characteristic in the SimpleGATTProfile
 *          service is retrieved from the profile, and then copied into the
 *          value of the the fourth characteristic.
 *
 * @param   None.
 *
 * @return  None.
 */
static void SimpleBLEPeripheral_performPeriodicTask(void)
{
    bStatus_t retVal = FAILURE;
    uint8_t Data[20] = {0x00,};

    //memcpy(Data_send ,info_t.info_data ,29);
    memset(Data, 0x00, 20);
    num++;
    Data[0] = num;
    uint8_t lengh = (num-1)*19;

    //DigitalkeyServicesession[0] = num;

    if(num == (shang+1)){
       memset(Data, 0x00, 20);
       Data[0] = num+0xa0;
      memcpy(Data+1,Data_send+lengh, yu);
      Util_stopClock(&periodicClock);
      uint32_t sumlen = (shang*19) + yu;
      if(ifLOG){
          DEBUG("sendlen:"); DEBUG((uint8_t*)convInt32ToText(sumlen)); DEBUG_NEWLINE();
      }
      //DEBUG(33333);DEBUG(Data1);DEBUG_NEWLINE();
      if(ifLOG){
          //DEBUG("send");DEBUG_NEWLINE();
      }
      //Send the notification
      if(shang == 1){
       retVal = DigitalkeyService_SetParameter(DKSERVER_CHAR_CMD, Data ,yu+1);
      }else if(shang == 5){
       retVal = DigitalkeyService_SetParameter(DKSERVER_CHAR_SESSION, Data ,yu+1);
      }else if((shang == 0)&&(yu == 16)){
       retVal = DigitalkeyService_SetParameter(DKSERVER_CHAR_CMD, Data ,yu+1);
      }
       num = 0;
       shang = 0;
       yu = 0;
    }else if(num <= shang){
    if(ifLOG){
        //DEBUG("send");DEBUG_NEWLINE();
    }
    Data[0] = num;
    memcpy(Data+1,Data_send+lengh ,19);
        //Send the notification
        if(shang == 1){
         retVal = DigitalkeyService_SetParameter(DKSERVER_CHAR_CMD, Data ,20);
        }else if(shang == 5){
         retVal = DigitalkeyService_SetParameter(DKSERVER_CHAR_SESSION, Data ,20);
        }
    }

// }
}
static void SimpleBLEPeripheral_performDisconnectTask(void)
{
    if ((gapProfileState == GAPROLE_CONNECTED)&&(statem.status!=WRITE_SESSION)){
        //GAPRole_TerminateConnection();
        //Util_stopClock(&disconnectClock);
        //DEBUG("Disconnect");
    }
    if (gapProfileState == GAPROLE_CONNECTED){
        HCI_ReadRssiCmd(gapRole_ConnectionHandle);
        //DEBUG("HCI_ReadRssiCmd");
    }
}
/*********************************************************************
 * @fn      SimpleBLEPeripheral_clockHandler
 *
 * @brief   Handler function for clock timeouts.
 *
 * @param   arg - event type
 *
 * @return  None.
 */
static void SimpleBLEPeripheral_clockHandler(UArg arg)
{
  // Wake up the application.
  Event_post(syncEvent, arg);
}
void SPPBLEServer_enqueueUARTMsg(uint8_t event, uint8_t *data, uint8_t len)
{
  sbpUARTEvt_t *pMsg;
  queueRec_t *pRec;

  //Enqueue message only in a connected state
  //if((gapProfileState == GAPROLE_CONNECTED) || (gapProfileState == GAPROLE_CONNECTED_ADV))
 //{
    // Create dynamic pointer to message.
    if (pMsg = ICall_malloc(sizeof(sbpUARTEvt_t)))
    {
      pMsg->event = event;
      pMsg->pData = (uint8 *)ICall_allocMsg(len);
      if(pMsg->pData)
      {
        //payload
        memcpy(pMsg->pData , data, len);
      }
      pMsg->length = len;

      // Enqueue the message.
      if ((pRec = ICall_malloc(sizeof(queueRec_t))))
      {
        pRec->pData = (uint8*)pMsg;
        // This is an atomic operation
        Queue_enqueue(appUARTMsgQueue, &pRec->_elem);

        Event_post(syncEvent, SBP_UART_QUEUE_EVT);
      }else
      {
        //DEBUG("appUARTMsgQueue ERROR");
        ICall_free(pMsg);
      }
    }
  //}
}

/*********************************************************************
 * @fn      SPPBLEServer_enqueueMsg
 *
 * @brief   Creates a message and puts the message in RTOS queue.
 *
 * @param   event - message event.
 * @param   state - message state.
 *
 * @return  None.
 */
static void SPPBLEServer_enqueueMsg(uint8_t event, uint8_t state)
{
  sbpEvt_t *pMsg;

  // Create dynamic pointer to message.
  if ((pMsg = ICall_malloc(sizeof(sbpEvt_t))))
  {
    pMsg->hdr.event = event;
    pMsg->hdr.state = state;

    // Enqueue the message.
    Util_enqueueMsg(appMsgQueue, syncEvent, (uint8*)pMsg);
  }
}

/*******************************************************************************
* @fn          convInt32ToText
*
* @brief       Converts 32 bit int to text
*
* @param       int32 value
*
* @return      char* - pointer to text buffer which is a file scope allocated array
*/
char* convInt32ToText(int32 value) {
    static char pValueToTextBuffer[12];
    char *pLast;
    char *pFirst;
    char last;
    uint8 negative;

    pLast = pValueToTextBuffer;

    // Record the sign of the value
    negative = (value < 0);
    value = ABS(value);

    // Print the value in the reverse order
    do {
        *(pLast++) = '0' + (uint8)(value % 10);
        value /= 10;
    } while (value);

    // Add the '-' when the number is negative, and terminate the string
    if (negative) *(pLast++) = '-';
    *(pLast--) = 0x00;

    // Now reverse the string
    pFirst = pValueToTextBuffer;
    while (pLast > pFirst) {
        last = *pLast;
        *(pLast--) = *pFirst;
        *(pFirst++) = last;
    }

    return pValueToTextBuffer;
}

/*********************************************************************
 * @fn      SimpleBLEPeripheral_processCharValueChangeEvt
 *
 * @brief   Process a pending Simple Profile characteristic value change
 *          event.
 *
 * @param   paramID - parameter ID of the value that was changed.
 *
 * @return  None.
 */
static uint8 newValue[DKSERVER_AUTH_LEN]={0};
static void SimpleBLEPeripheral_processCharValueChangeEvt(uint8_t paramID)
{
    int ret=0;
    uint32_t returnBytes=0;
    uint8 data[20]={0x00,};
    uint8 number;

    //if((xiaochengxu == true)&&(paramID == DKSERVER_CHAR_AUTH)){
    if(xiaochengxu == true){
        memset(data, 0x00, 20);
        ret=DigitalkeyService_GetParameter(paramID, data, &returnBytes);
        if(ret != SUCCESS || returnBytes ==0){
            return;
        }

        //int yu = (int)(data[0]);
        //DEBUG("data"); DEBUG((uint8_t*)convInt32ToText(yu)); DEBUG("\r\n");

        if(data[0] <= 0xa0){
            number = data[0];
            if(0x01 == number){
                memset(newValue, 0x00, DKSERVER_AUTH_LEN);
            }
            //DEBUG("haha");DEBUG_NEWLINE();
            memcpy(newValue+19*(number-1), data+1, 19 );
        }else if((data[0] > 0xa0)&&(data[0] < 0xa8)){
            number = data[0] - 0xa0;
            //int auth = 19*(number-1)+returnBytes-1;

            memcpy(newValue+19*(number-1), data+1, returnBytes );
            returnBytes = (19*(number-1))+returnBytes-1;
            if(ifLOG){
                //DEBUG("processChar");DEBUG_NEWLINE();
                DEBUG("returnBytes:"); DEBUG((uint8_t*)convInt32ToText((int)returnBytes)); DEBUG_NEWLINE();
            }
            Handle_Character(paramID ,newValue ,returnBytes);
        }
    }else{
        memset(newValue, 0x00, DKSERVER_AUTH_LEN);
        ret=DigitalkeyService_GetParameter(paramID, newValue, &returnBytes);
        //DEBUG("WRITE");DEBUG_NEWLINE();
        if(true == ifLOG){
            DEBUG("receiBytes:"); DEBUG((uint8_t*)convInt32ToText((int)returnBytes)); DEBUG_NEWLINE();
        }
        if(ret != SUCCESS || returnBytes ==0){
            return;
        }
        Handle_Character(paramID,newValue,returnBytes);
    }
/*
    uint8_t enableUpdateRequest = DEFAULT_ENABLE_UPDATE_REQUEST;
    uint16_t desiredMinInterval = DEFAULT_DESIRED_MIN_CONN_INTERVAL;
    uint16_t desiredMaxInterval = DEFAULT_DESIRED_MAX_CONN_INTERVAL;
    uint16_t desiredSlaveLatency = DEFAULT_DESIRED_SLAVE_LATENCY;
    uint16_t desiredConnTimeout = DEFAULT_DESIRED_CONN_TIMEOUT;
    GAPRole_SetParameter(GAPROLE_PARAM_UPDATE_ENABLE, sizeof(uint8_t),&enableUpdateRequest);
    GAPRole_SetParameter(GAPROLE_MIN_CONN_INTERVAL, sizeof(uint16_t),&desiredMinInterval);
    GAPRole_SetParameter(GAPROLE_MAX_CONN_INTERVAL, sizeof(uint16_t),&desiredMaxInterval);
    GAPRole_SetParameter(GAPROLE_SLAVE_LATENCY, sizeof(uint16_t),&desiredSlaveLatency);
    GAPRole_SetParameter(GAPROLE_TIMEOUT_MULTIPLIER, sizeof(uint16_t),&desiredConnTimeout);
*/
}



#ifdef FEATURE_OAD
/*********************************************************************
 * @fn      SimpleBLEPeripheral_processOadWriteCB
 *
 * @brief   Process a write request to the OAD profile.
 *
 * @param   event      - event type:
 *                       OAD_WRITE_IDENTIFY_REQ
 *                       OAD_WRITE_BLOCK_REQ
 * @param   connHandle - the connection Handle this request is from.
 * @param   pData      - pointer to data for processing and/or storing.
 *
 * @return  None.
 */
void SimpleBLEPeripheral_processOadWriteCB(uint8_t event, uint16_t connHandle,
                                           uint8_t *pData)
{
  oadTargetWrite_t *oadWriteEvt = ICall_malloc( sizeof(oadTargetWrite_t) + \
                                             sizeof(uint8_t) * OAD_PACKET_SIZE);

  if ( oadWriteEvt != NULL )
  {
    oadWriteEvt->event = event;
    oadWriteEvt->connHandle = connHandle;

    oadWriteEvt->pData = (uint8_t *)(&oadWriteEvt->pData + 1);
    memcpy(oadWriteEvt->pData, pData, OAD_PACKET_SIZE);

    Queue_put(hOadQ, (Queue_Elem *)oadWriteEvt);

    // Post the application's event.  For OAD, no event flag is used.
    Event_post(syncEvent, SBP_QUEUE_PING_EVT);
  }
  else
  {
    // Fail silently.
  }
}
#endif //FEATURE_OAD

/*********************************************************************
*********************************************************************/
